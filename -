âœ…Â TCR/Telnyx Collections Campaign Pre-Submission Compliance Checklist (v1.0)
Purpose:â€¨The â€œCollections Compliance Agentâ€ will use this checklist to evaluate:
	â€¢	Brand data
	â€¢	Website content
	â€¢	Message templates
	â€¢	Opt-in flows
	â€¢	Privacy/Terms pages
	â€¢	URLs & domains
	â€¢	Tone & language
	â€¢	FDCPA/CFPB concerns
	â€¢	CTIA & TCPA compliance
	â€¢	TCR formatting & submission requirements
Outcome:â€¨A binary recommendation:â€¨APPROVABLE (â‰¥99% likelihood)Â orÂ REJECTION LIKELYâ€¨Plus a list of specific issues to correct.

ğŸ§©Â SECTION A â€” BRAND IDENTITY & CATEGORY REVIEW
A1. Brand Website Review
Agent reviews every page of the brandâ€™s website (home, about, services, footer links).
Must confirm:
	â€¢	Â WebsiteÂ existsÂ and loads correctly
	â€¢	Â Website clearly identifies the brand
	â€¢	Â Website doesÂ notÂ use URL shorteners or redirects to suspicious pages
	â€¢	Â Website domain matches the brand name or parent company
	â€¢	Â Website does not mentionÂ third-party debt collectionÂ in a way that violates carrier restrictions
	â€¢	Â Website does not implyÂ marketingÂ orÂ lead generationÂ intent
	â€¢	Â Website does not advertise services toÂ other businessesÂ for outbound messaging (this triggers â€œaggregatorâ€ rejection)
Auto-fail triggers:
	â€¢	Â â€œThird-party debt collectorâ€ or â€œWe collect debts on behalf of othersâ€
	â€¢	Â â€œSkip-tracingâ€ or similar prohibited practices
	â€¢	Â Payday loan content
	â€¢	Â Personal loan solicitations
	â€¢	Â Lead generation / data brokerage language
	â€¢	Â Fintech products that imply risk (crypto, credit repair, etc.)
	â€¢	Â Website unrelated to finance or collections (inconsistent brand)

A2. Brand Category Validation
For collections, brand must fall under allowed financial categories:
Allowed:
	â€¢	Â Debt servicing
	â€¢	Â Existing account notifications
	â€¢	Â Payment reminders
	â€¢	Â Statement availability
	â€¢	Â Account login access
Not allowed:
	â€¢	Â Marketing to generate payments (â€œtake advantage of this offerâ€)
	â€¢	Â New debt solicitations
	â€¢	Â Loan offers
	â€¢	Â Cross-selling or upselling
	â€¢	Â Early-stage collection harassment tone
	â€¢	Â Mention of â€œpre-legal,â€ â€œlegal escalation,â€ etc.

ğŸ§©Â SECTION B â€” OPT-IN VALIDATION (THE #1 CAUSE OF REJECTIONS)
B1. Opt-In Method Completeness
Agent checks:
	â€¢	Â Web opt-in flow described
	â€¢	Â Opt-in checkbox language provided
	â€¢	Â Link to opt-in page (if applicable)
	â€¢	Â Phone/verbal opt-in script present
	â€¢	Â Email confirmation opt-in flow fully described
Auto-fail triggers:
	â€¢	Â â€œCustomers provide their number when calling inâ€ (non-compliant)
	â€¢	Â â€œWe have an existing business relationshipâ€ (not enough for SMS)
	â€¢	Â Prechecked opt-in box
	â€¢	Â Passive consent (â€œby using our site, you agreeâ€¦â€)
	â€¢	Â No STOP/HELP instructions in initial message

B2. Opt-In Proof
	â€¢	Â Screenshots or sample form fields provided
	â€¢	Â Consent language visible
	â€¢	Â Clear wording that messages are aboutÂ existing accounts
Required wording for collections:
â€œI agree to receive SMS notifications regarding my existing account. Message/data rates may apply. Reply STOP to cancel.â€

ğŸ§©Â SECTION C â€” MESSAGE TEMPLATE COMPLIANCE
C1. Template Required Elements
Every message must include:
	â€¢	Â Brand name (no placeholders allowed)
	â€¢	Â Purpose of message clearly stated
	â€¢	Â STOP instructions on first message
	â€¢	Â HELP support info available somewhere
	â€¢	Â No marketing/promotional language
	â€¢	Â FDCPA disclosure (for collections):â€¨â€œThis is a communication from a debt collector.â€

C2. Dynamic Field Compliance
Allowed:
	â€¢	Â {{FirstName}}
	â€¢	Â {{Last4}}
	â€¢	Â {{AmountDue}}
	â€¢	Â {{DueDate}}
Not allowed:
	â€¢	Â {{BrandName}}
	â€¢	Â {{URL}}
	â€¢	Â {{Company}}
	â€¢	Â {{AgentName}}
	â€¢	Â {{VariableLink}}

C3. Language & Tone Audit
Agent checks for:
Must NOT include:
	â€¢	Â Threatening language
	â€¢	Â Legal escalation language
	â€¢	Â â€œUrgent,â€ â€œFinal Notice,â€ â€œLast Attemptâ€
	â€¢	Â â€œWe are attempting to collectâ€¦â€Â without identifying sender
	â€¢	Â Pressure tactics (â€œrespond immediatelyâ€)
	â€¢	Â Misleading statements (â€œimportant matterâ€)
	â€¢	Â Loan solicitations
	â€¢	Â Financial advice
	â€¢	Â â€œClick here to prevent additional feesâ€
Must include:
	â€¢	Â Informational, factual tone
	â€¢	Â Link to secure portal
	â€¢	Â No request to reply with personal info
	â€¢	Â No conversational SMS (must avoid looking like two-way negotiation)

ğŸ§©Â SECTION D â€” URL & DOMAIN VALIDATION
D1. Domain Checks
Agent verifies:
	â€¢	Â All URLs resolve
	â€¢	Â Domain is HTTPS
	â€¢	Â No URL shorteners
	â€¢	Â No redirects
	â€¢	Â Domain is owned by the client brand
	â€¢	Â Domain does not include inappropriate subdomains (e.g., unsecured login pages)

D2. Portal Login Page Review
Must confirm:
	â€¢	Â Page is secure
	â€¢	Â SSL certificate valid
	â€¢	Â Page refers toÂ existing customers only
	â€¢	Â No language that suggests marketing

ğŸ§©Â SECTION E â€” TERMS & PRIVACY VALIDATION
E1. Compliance pages must exist and load
	â€¢	Â Privacy Policy URL
	â€¢	Â Terms & Conditions URL
	â€¢	Â Both pages present and functional
	â€¢	Â Brand name appears on these pages
	â€¢	Â No contradictory opt-in claims (common fail point)

E2. Required Regulatory Language
Privacy policy must include:
	â€¢	Â How customer data is used
	â€¢	Â How SMS preferences are managed
	â€¢	Â How customers opt out
	â€¢	Â No sharing with third parties for marketing

ğŸ§©Â SECTION F â€” SUPPORT & ESCALATION REQUIREMENTS
Required:
	â€¢	Â Support email
	â€¢	Â Support phone number
	â€¢	Â Hours of operation
	â€¢	Â Must match HELP autoresponder

ğŸ§©Â SECTION G â€” TCR STRUCTURE VALIDATION
Agent verifies that the submission form fields align with TCR formatting:
	â€¢	Â All fields filled
	â€¢	Â No â€œTBDâ€
	â€¢	Â No null values
	â€¢	Â Brand name matches legal entity
	â€¢	Â Campaign type selected correctly
	â€¢	Â Message examples match declared use case
	â€¢	Â Short description matches actual message content
Mismatch is a guaranteed reject.

ğŸ§©Â SECTION H â€” CARRIER RISK CHECK
Agent evaluates HIGH-RISK flags:
Automatic Rejection:
	â€¢	Â Third-party debt collector (unless structured properly)
	â€¢	Â Credit repair
	â€¢	Â Loan modification
	â€¢	Â Foreclosure assistance
	â€¢	Â Payday lending
	â€¢	Â Crypto finance
	â€¢	Â Insurance solicitation
	â€¢	Â Any outbound lead gen
Allowed with Proper Messaging:
	â€¢	Â Existing debt servicing
	â€¢	Â Account notifications
	â€¢	Â Payment reminders
	â€¢	Â Document availability

ğŸ§©Â SECTION I â€” FDCPA, TCPA, CTIA LEGAL COMPLIANCE
Must include:
	â€¢	Â â€œThis is a communication from a debt collector.â€
	â€¢	Â No third-party disclosure of debt
	â€¢	Â No sending outside allowed hours (agent notes but carriers do not check)
	â€¢	Â No misleading or deceptive claims
	â€¢	Â No response-required negotiations via SMS

ğŸ§©Â SECTION J â€” FINAL APPROVAL SCORE (Agent Output)
The agent will output:
Status:
	â€¢	APPROVABLE (â‰¥99%)
	â€¢	REJECTION LIKELY
Score:
Calculated by weighting issues in each section.
Report:
	â€¢	Pass/Fail on each section
	â€¢	Exact reasons for likely rejection
	â€¢	Steps required to fix
	â€¢	Regulatory citations (FDCPA/TCPA/CTIA)
	â€¢	Carrier justification patterns seen in prior cases

ğŸ§¬Â Evolution Mechanism (How the Checklist Updates Over Time)
The compliance agent should update this checklist when:
	â€¢	Â New rejection reasons appear in future Telnyx/TCR feedback
	â€¢	Â New carrier rules are added (e.g., AT&T revisions)
	â€¢	Â CTIA updates guidelines
	â€¢	Â Congress/CFPB updates FDCPA interpretations
	â€¢	Â SMS phishing/abuse patterns cause stricter controls
	â€¢	Â Industry trends indicate risk tightening (e.g., crypto crackdowns)
	â€¢	Â Account-level anomalies appear (e.g., high opt-out rates)
Each update creates:
	â€¢	New version number
	â€¢	Changelog
	â€¢	New test cases



Iâ€™ll give you something you canÂ implement:
	â€¢	A clearÂ architecture
	â€¢	AÂ data modelÂ for campaign submissions
	â€¢	AÂ rule engineÂ design (with severity, scoring, and versioning)
	â€¢	ExampleÂ code skeletonÂ (TypeScript/Node) including:
	â€¢	Rule definitions
	â€¢	Website scanning hooks
	â€¢	AÂ runComplianceCheck()Â you can wire into CCAI
You can hand this to an engineer and say: â€œBuild this.â€

1. High-level architecture
Think of the â€œCollections Compliance Agentâ€ as this pipeline:
	â€¢	Ingest Submission
	â€¢	Parse your existing campaign submission form (Excel/CSV/API/UI) into a normalized object.
	â€¢	Enrich Context
	â€¢	Crawl brand website(s) and referenced URLs (login portal, privacy, terms).
	â€¢	Extract text content for analysis.
	â€¢	(Optional later) Query your own â€œknown rejectionsâ€ DB for patterns.
	â€¢	Run Rules Engine
	â€¢	Deterministic checks (required fields, URLs, FDCPA language, STOP/HELP, etc.).
	â€¢	Content checks on website + templates (third-party collector language, loan solicitations, etc.).
	â€¢	Risk classification & score.
	â€¢	Produce Report
	â€¢	Overall status:Â APPROVABLEÂ /Â REJECTION LIKELY
	â€¢	0â€“100 score
	â€¢	Issues grouped by section (Brand, Website, Opt-in, Templates, etc.)
	â€¢	â€œFix this to passâ€ recommendations.
	â€¢	Version & Learn
	â€¢	Each run tagged with aÂ rulesVersion.
	â€¢	When you get Telnyx rejection/approval results, you update rules and bump version.

2. Core data model (for the engine)
Example in TypeScript, but same idea in any language:
// Core submission object normalized from your form
export interface CampaignSubmission {
  brandName: string;
  brandWebsite: string;
  supportEmail?: string;
  supportPhone?: string;
  privacyUrl?: string;
  termsUrl?: string;

  useCase: string;                  // e.g. "Debt Servicing / Account Notifications"
  campaignDescription: string;
  vertical: string;                 // e.g. "Financial Services - Collections"

  optInDescription: string;         // narrative
  optInChannels: ("web" | "phone" | "email" | "sms")[];

  sampleMessages: string[];
  helpResponse?: string;
  stopResponse?: string;

  // Optional extra URLs (customer portal, forms, etc.)
  additionalUrls?: string[];
}
Website scan result
export interface WebsiteScan {
  url: string;
  status: number;
  textContent: string;        // normalized visible text
  metaDescription?: string;
  headings?: string[];
}
Rule and result types
export type RuleSeverity = "CRITICAL" | "MAJOR" | "MINOR" | "INFO";

export interface RuleResult {
  ruleId: string;
  name: string;
  section: string;       // e.g. "Brand", "Website", "Templates"
  severity: RuleSeverity;
  passed: boolean;
  message: string;       // human-readable explanation
  details?: any;         // optional extra data
}

export interface ComplianceReport {
  rulesVersion: string;
  overallStatus: "APPROVABLE" | "REJECTION_LIKELY";
  score: number;         // 0â€“100
  results: RuleResult[];
}

3. Rule engine design
Rules are just functions overÂ (submission, websiteContext)Â that returnÂ RuleResult.
export interface RuleContext {
  submission: CampaignSubmission;
  websites: WebsiteScan[];
}

export interface ComplianceRule {
  id: string;
  name: string;
  section: string;
  severity: RuleSeverity;
  evaluate(ctx: RuleContext): RuleResult;
}
Then a simple engine:
export class ComplianceEngine {
  constructor(
    private rules: ComplianceRule[],
    private rulesVersion: string = "v1.0"
  ) {}

  run(ctx: RuleContext): ComplianceReport {
    const results = this.rules.map(rule => rule.evaluate(ctx));

    // Any failed CRITICAL or MAJOR rule â†’ REJECTION_LIKELY
    const hasSeriousFailure = results.some(r => !r.passed && (r.severity === "CRITICAL" || r.severity === "MAJOR"));

    // Simple scoring: start from 100 and deduct
    let score = 100;
    for (const r of results) {
      if (!r.passed) {
        if (r.severity === "CRITICAL") score -= 30;
        else if (r.severity === "MAJOR") score -= 15;
        else if (r.severity === "MINOR") score -= 5;
      }
    }
    if (score < 0) score = 0;

    const overallStatus = hasSeriousFailure ? "REJECTION_LIKELY" : "APPROVABLE";

    return {
      rulesVersion: this.rulesVersion,
      overallStatus,
      score,
      results,
    };
  }
}

4. Example rules based on the checklist
Iâ€™ll show a few key ones; you can expand this list over time.
4.1 Brand website: third-party debt collector detection (your Telnyx failure)
const THIRD_PARTY_PATTERNS = [
  /third[-\s]?party debt collector/i,
  /we collect debts on behalf of/i,
  /collection agency/i,
  /debt collection agency/i
];

export const WebsiteThirdPartyDebtRule: ComplianceRule = {
  id: "A1-THIRDPARTY-DEBT",
  name: "Website references third-party debt collection (high-risk)",
  section: "Brand",
  severity: "CRITICAL",
  evaluate(ctx: RuleContext): RuleResult {
    const allText = ctx.websites.map(w => w.textContent).join("\n").toLowerCase();

    const match = THIRD_PARTY_PATTERNS.find(p => p.test(allText));

    const passed = !match;
    return {
      ruleId: "A1-THIRDPARTY-DEBT",
      name: "Website references third-party debt collection (high-risk)",
      section: "Brand",
      severity: "CRITICAL",
      passed,
      message: passed
        ? "No explicit third-party debt collection language detected on website."
        : "Website explicitly references third-party debt collection, which carriers classify as high-risk financial services and will be rejected unless handled via special flow.",
      details: match?.toString(),
    };
  },
};
4.2 Required URLs present
export const RequiredUrlsRule: ComplianceRule = {
  id: "E1-REQUIRED-URLS",
  name: "Privacy & Terms URLs present",
  section: "Legal",
  severity: "MAJOR",
  evaluate({ submission }: RuleContext): RuleResult {
    const missing: string[] = [];
    if (!submission.privacyUrl) missing.push("privacyUrl");
    if (!submission.termsUrl) missing.push("termsUrl");

    const passed = missing.length === 0;

    return {
      ruleId: "E1-REQUIRED-URLS",
      name: "Privacy & Terms URLs present",
      section: "Legal",
      severity: "MAJOR",
      passed,
      message: passed
        ? "Privacy and Terms URLs are provided."
        : `Missing required URL(s): ${missing.join(", ")}.`,
      details: { missing },
    };
  },
};
4.3 Brand in every sample message
export const BrandInMessagesRule: ComplianceRule = {
  id: "C1-BRAND-IN-MESSAGES",
  name: "Brand name appears in every sample message",
  section: "Templates",
  severity: "MAJOR",
  evaluate({ submission }: RuleContext): RuleResult {
    const { brandName, sampleMessages } = submission;

    const failingIndices: number[] = [];
    sampleMessages.forEach((msg, i) => {
      if (!msg.toLowerCase().includes(brandName.toLowerCase())) {
        failingIndices.push(i);
      }
    });

    const passed = failingIndices.length === 0;

    return {
      ruleId: "C1-BRAND-IN-MESSAGES",
      name: "Brand name appears in every sample message",
      section: "Templates",
      severity: "MAJOR",
      passed,
      message: passed
        ? "Brand name is present in all sample messages."
        : `Brand name is missing from sample messages at indices: ${failingIndices.join(", ")}.`,
      details: { failingIndices },
    };
  },
};
4.4 FDCPA disclosure present
export const FdcpaDisclosureRule: ComplianceRule = {
  id: "I1-FDCPA-DISCLOSURE",
  name: "FDCPA disclosure present in sample messages",
  section: "Legal",
  severity: "MAJOR",
  evaluate({ submission }: RuleContext): RuleResult {
    const phrase = "this is a communication from a debt collector";
    const hasDisclosure = submission.sampleMessages.some(m =>
      m.toLowerCase().includes(phrase)
    );

    return {
      ruleId: "I1-FDCPA-DISCLOSURE",
      name: "FDCPA disclosure present in sample messages",
      section: "Legal",
      severity: "MAJOR",
      passed: hasDisclosure,
      message: hasDisclosure
        ? "At least one sample message includes FDCPA disclosure."
        : "FDCPA disclosure ('This is a communication from a debt collector.') is missing from all sample messages and will likely cause rejection.",
    };
  },
};
4.5 STOP/HELP in initial message
export const StopHelpRule: ComplianceRule = {
  id: "B1-STOP-HELP",
  name: "STOP and HELP instructions provided",
  section: "Opt-In",
  severity: "MAJOR",
  evaluate({ submission }: RuleContext): RuleResult {
    const firstMessage = submission.sampleMessages[0] || "";
    const hasStop = /reply\s+stop/i.test(firstMessage);
    const hasHelp = /reply\s+help/i.test(firstMessage);

    const passed = hasStop && hasHelp;

    return {
      ruleId: "B1-STOP-HELP",
      name: "STOP and HELP instructions provided",
      section: "Opt-In",
      severity: "MAJOR",
      passed,
      message: passed
        ? "STOP and HELP instructions are present in the initial sample message."
        : "Initial message must include 'Reply STOP to opt out' and 'Reply HELP for assistance'.",
      details: { hasStop, hasHelp },
    };
  },
};
4.6 Prohibited placeholders
const DISALLOWED_PLACEHOLDERS = [
  "{{BrandName}}",
  "{{LoginURL}}",
  "{{URL}}",
  "{{CompanyName}}",
];

export const DisallowedPlaceholderRule: ComplianceRule = {
  id: "C2-DISALLOWED-PLACEHOLDERS",
  name: "Disallowed placeholders in messages",
  section: "Templates",
  severity: "MAJOR",
  evaluate({ submission }: RuleContext): RuleResult {
    const offending: { index: number; placeholder: string }[] = [];

    submission.sampleMessages.forEach((msg, i) => {
      DISALLOWED_PLACEHOLDERS.forEach(ph => {
        if (msg.includes(ph)) offending.push({ index: i, placeholder: ph });
      });
    });

    const passed = offending.length === 0;

    return {
      ruleId: "C2-DISALLOWED-PLACEHOLDERS",
      name: "Disallowed placeholders in messages",
      section: "Templates",
      severity: "MAJOR",
      passed,
      message: passed
        ? "No disallowed placeholders detected in sample messages."
        : `Disallowed placeholders found: ${offending
            .map(o => `${o.placeholder} in message[${o.index}]`)
            .join("; ")}`,
      details: offending,
    };
  },
};

5. Website scanning layer
Youâ€™ll want a small service to pull and normalize HTML â†’ text:
import fetch from "node-fetch";
import { JSDOM } from "jsdom";

export async function scanWebsite(url: string): Promise<WebsiteScan> {
  const res = await fetch(url);
  const html = await res.text();
  const dom = new JSDOM(html);
  const doc = dom.window.document;

  const textContent = doc.body.textContent || "";

  const headings = Array.from(doc.querySelectorAll("h1, h2, h3")).map(
    h => h.textContent || ""
  );

  const metaDesc =
    doc.querySelector("meta[name='description']")?.getAttribute("content") ||
    undefined;

  return {
    url,
    status: res.status,
    textContent,
    metaDescription: metaDesc,
    headings,
  };
}
Then, before running the engine:
async function runComplianceCheck(submission: CampaignSubmission): Promise<ComplianceReport> {
  const urls = [
    submission.brandWebsite,
    submission.privacyUrl,
    submission.termsUrl,
    ...(submission.additionalUrls || []),
  ].filter(Boolean) as string[];

  const websites = await Promise.all(urls.map(scanWebsite));

  const engine = new ComplianceEngine(
    [
      WebsiteThirdPartyDebtRule,
      RequiredUrlsRule,
      BrandInMessagesRule,
      FdcpaDisclosureRule,
      StopHelpRule,
      DisallowedPlaceholderRule,
      // ...add the rest from the checklist
    ],
    "v1.0"
  );

  return engine.run({ submission, websites });
}

6. How this evolves as you learn
Every time:
	â€¢	A campaign isÂ rejected, you:
	â€¢	Store Telnyx/TCR reason.
	â€¢	Add or adjust rules to catch it earlier.
	â€¢	BumpÂ rulesVersionÂ toÂ v1.1,Â v1.2, etc.
	â€¢	A campaign isÂ approved, you:
	â€¢	Optionally log the report and validate that nothing was â€œoverly strict.â€
	â€¢	Adjust severity or thresholds if you find false positives.
This gives you:
	â€¢	AÂ living, versioned compliance engine.
	â€¢	Traceability: â€œThis campaign was evaluated under ruleset v1.3.â€
	â€¢	A very nice story for clients and carriers: â€œWe pre-validate all campaigns against a codified compliance framework.â€

If youâ€™d like, next step I can:
	â€¢	Turn this into aÂ full JSON rule configurationÂ so non-devs can manage rules.
	â€¢	Or adapt this intoÂ PythonÂ if thatâ€™s a better fit for your stack.
	â€¢	Or map it directly onto yourÂ existing Excel submissionÂ columns so itâ€™s plug-and-play with your current form.

